#***************************************************************************
#*                                                                         *
#*   Copyright (c) 2017 Yorik van Havre <yorik@uncreated.net>              *
#*                                                                         *
#*   This program is free software; you can redistribute it and/or modify  *
#*   it under the terms of the GNU Lesser General Public License (LGPL)    *
#*   as published by the Free Software Foundation; either version 2 of     *
#*   the License, or (at your option) any later version.                   *
#*   for detail see the LICENCE text file.                                 *
#*                                                                         *
#*   This program is distributed in the hope that it will be useful,       *
#*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
#*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
#*   GNU Library General Public License for more details.                  *
#*                                                                         *
#*   You should have received a copy of the GNU Library General Public     *
#*   License along with this program; if not, write to the Free Software   *
#*   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  *
#*   USA                                                                   *
#*                                                                         *
#***************************************************************************

# Luxrender renderer for FreeCAD

# This file can also be used as a template to add more rendering engines.
# You will need to make sure your file is named with a same name (case sensitive)
# That you will use everywhere to describe your renderer, ex: Appleseed or Povray


# A render engine module must contain the following functions:
#
#    writeCamera(por,rot,up,target): returns a string containing an openInventor camera string in renderer format
#    writeObject(name,mesh,material): returns a string containing a RaytracingView object in renderer format
#    render(project,prefix,external,output,width,height): renders the given project, external means
#                                                         if the user wishes to open the render file
#                                                         in an external application/editor or not. If this
#                                                         is not supported by your renderer, you can simply
#                                                         ignore it
#
# Additionally, you might need/want to add:
#
#    Preference page items, that can be used in your functions below
#    An icon under the name Renderer.svg (where Renderer is the name of your Renderer


import FreeCAD
import math
import os
import re
import tempfile
import shlex
import subprocess
import sys


def writeCamera(pos,rot,up,target):

    # this is where you create a piece of text in the format of
    # your renderer, that represents the camera.

    pos = str(pos.x) + " " + str(pos.y) + " " + str(pos.z)
    target = str(target.x) + " " + str(target.y) + " " + str(target.z)
    up = str(up.x) + " " + str(up.y) + " " + str(up.z)

    cam  = "# declares position and view direction\n"
    cam += "# Generated by FreeCAD (http://www.freecadweb.org/)\n"
    cam += "scene.camera.type = perspective\n"
    cam += "scene.camera.lookat.orig = " + pos + "\n"
    cam += "scene.camera.lookat.target = " + target + "\n"
    cam += "scene.camera.up = " + up + "\n"
    return cam

def writeParameter(pre, post, name, value):
    if value is not None:
        return pre +"." + name + "." + post + " = " + value + "\n"
    return ""

def writeMetal2(name, material):
    matdef = ""

    if material.check("LuxCore_Metal2_FresnelColor"):
        fresnelname = name + "_fresnel"
        matdef += writeParameter("scene.textures", "type", fresnelname, "fresnelcolor")
        matdef += writeParameter("scene.textures", "kr", fresnelname, material.getColorsSpace("LuxCore_Metal2_FresnelColor"))
        matdef += writeParameter("scene.materials", "fresnel", name, fresnelname)
    matdef += writeParameter("scene.materials", "type", name, "metal2")
    matdef += writeParameter("scene.materials", "transparency", name, material.getPercentFloatInverted("Transparency"))
    matdef += writeParameter("scene.materials", "uroughness", name, material.getFloat("LuxCore_Metal2_URoughness"))
    matdef += writeParameter("scene.materials", "vroughness", name, material.getFloat("LuxCore_Metal2_VRoughness"))
    return matdef

def writeRoughGlass(name, material):
    matdef = writeParameter("scene.materials", "type", name, "roughglass")
    matdef += writeParameter("scene.materials", "kr", name, material.getColorsSpace("LuxCore_RoughGlass_ReflectedColor"))
    matdef += writeParameter("scene.materials", "kt", name, material.getColorsSpace("LuxCore_RoughGlass_TransmittedColor"))
    matdef += writeParameter("scene.materials", "interiorior", name, material.getFloat("LuxCore_RoughGlass_InteriorIOR"))
    matdef += writeParameter("scene.materials", "exteriorior", name, material.getFloat("LuxCore_RoughGlass_ExteriorIOR"))
    matdef += writeParameter("scene.materials", "uroughness", name, material.getFloat("LuxCore_RoughGlass_URoughness"))
    matdef += writeParameter("scene.materials", "vroughness", name, material.getFloat("LuxCore_RoughGlass_VRoughness"))
    matdef += writeParameter("scene.materials", "transparency", name, material.getPercentFloatInverted("Transparency"))
    return matdef

def writeMatte(name, material):
    matdef = writeParameter("scene.materials", "type", name, "matte")
    matdef += writeParameter("scene.materials", "kd", name, material.getColorsSpace("DiffuseColor"))
    matdef += writeParameter("scene.materials", "transparency", name, material.getPercentFloatInverted("Transparency"))
    return matdef

#Added a custom ply exporter here because the one in freecad uses a slightly different format
#then what luxcorerender expects (face.vertex_indices vs face.vertex_index)
def writeMeshPLY(mesh):
    plyDef = "ply\n"
    plyDef += "format ascii 1.0\n"
    plyDef += "element vertex " + str(len(mesh.Topology[0])) + "\n"
    plyDef += "property float x\n"
    plyDef += "property float y\n"
    plyDef += "property float z\n"
    plyDef += "element face " + str(len(mesh.Topology[1])) + "\n"
    plyDef += "property list uchar uint vertex_indices\n"
    plyDef += "end_header\n"
    for p in mesh.Topology[0]:
        plyDef += str(p[0]) + " " + str(p[1]) + " " + str(p[2]) + "\n"
    #TODO: need to support faces with more than 3 vertices?
    for f in mesh.Topology[1]:
        plyDef += "3 " + str(f[0]) + " " + str(f[1]) + " " + str(f[2]) + "\n"
    return plyDef

def writeObject(name,mesh,material):

    # This is where you write your object/view in the format of your
    # renderer. "obj" is the real 3D object handled by this project, not
    # the project itself. This is your only opportunity
    # to write all the data needed by your object (geometry, materials, etc)
    # so make sure you include everything that is needed

    matname = name+"_mat"

    alpha = material.getNumPercentFloatInverted("Transparency")

    objdef = ""

    # write the mesh as a ply tempfile
    fd, meshfile = tempfile.mkstemp(suffix=".ply", prefix="_")
    with os.fdopen(fd, "w", newline='\n') as f:
        f.write(writeMeshPLY(mesh))

    matType = material.getString("LuxCore_Material")
    if matType is not None:
        matType = matType.lower()
    if matType == "metal2":
        objdef += writeMetal2(matname, material)
    elif matType == "roughglass":
        objdef += writeRoughGlass(matname, material)
    else:
        objdef += writeMatte(matname, material)

    objdef += writeParameter("scene.objects", "material", name, matname)
    #TODO: use the new "shape" definition
    objdef += writeParameter("scene.objects", "ply", name, meshfile)

    return objdef


def render(project,prefix,external,output,width,height):

    # here you trigger a render by firing the renderer
    # executable and passing it the needed arguments, and
    # the file it needs to render

    f = open(project.PageResult,"r")
    fd, fp = tempfile.mkstemp(prefix=project.Name,suffix=".scn")
    t = f.read()
    f.close()

    splitIndex = t.index("#SceneFileMarker")

    #write scene file
    sceneContent = t[splitIndex:]
    fdScn, scnFile = tempfile.mkstemp(suffix=".scn", prefix=project.Name)
    with os.fdopen(fdScn, "w") as f:
        f.write(sceneContent)

    #write config file
    cfgContent = t[:splitIndex]
    cfgContent += "film.width = " + str(width) + "\n"
    cfgContent += "film.height = " + str(height) + "\n"
    cfgContent += "scene.file = " + scnFile + "\n"

    fdCfg, cfgFile = tempfile.mkstemp(suffix=".cfg", prefix=project.Name)
    with os.fdopen(fdCfg, "w", newline='\n') as f:
        f.write(cfgContent)

    project.PageResult = cfgFile
    FreeCAD.ActiveDocument.recompute()

    p = FreeCAD.ParamGet("User parameter:BaseApp/Preferences/Mod/Render")
    if external:
        rpath = p.GetString("LuxRenderPath","")
        args = p.GetString("LuxParameters","")
    else:
        rpath = p.GetString("LuxConsolePath","")
        args = p.GetString("LuxParameters","")
    if not rpath:
        FreeCAD.Console.PrintError("Unable to locate renderer executable. Please set the correct path in Edit -> Preferences -> Render")
        return
    if args:
        args += " "

    # Call Luxrender
    cmd = prefix+rpath+" "+args+cfgFile+"\n"
    FreeCAD.Console.PrintMessage(cmd)
    try:
        p = subprocess.Popen(shlex.split(cmd, posix="win" not in sys.platform))
    except OSError as e:
        FreeCAD.Console.PrintError("Luxrender call failed: '" + e.strerror +"'\n")
    return
